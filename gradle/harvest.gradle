apply from: "$rootDir/gradle/base.gradle"

import com.xlson.groovycsv.CsvParser
import java.time.*
import java.time.format.DateTimeFormatter

// TODO find a way to general import buildscript deps...
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

///////  Configuration

ext {
	// The Harvest server configuration
	harvest = [
		// The harvest broker name.
		broker: null,
		
		// The harvest project name.
		project: null,
		
		// The harvest viewpath.
		viewpath: null,

		// The harvest state.
		state: null
	]
	
	// The git bridge configuration, override in used project
	gitbridge = [
		// The store that holds meta data about harvest, e.g. the last fetched date and version.
		datadir: null,
		
		// The root directory of the git repository.
		gitroot: null
	]

	formats = [
		US_DATE: DateTimeFormatter.ofPattern("MM/dd/yyyy"),
		HARVEST: DateTimeFormatter.ofPattern("MM-dd-yyyy;HH:mm:ss"),
		GIT_COMMIT: DateTimeFormatter.ofPattern("MM/dd/yyyy'T'HH:mm:ss")
	]
}

///////  Updating the Git repository

/**
 * Returns the array to execute the given harvest CLI command. Handles login based on the configured harvest options.
 */
def getHarvestCommand = { tool ->
	def command = [ tool, "-b", harvest.broker, "-en", harvest.project, "-vp", harvest.viewpath, "-o", "${gitbridge.datadir}/${tool}.log" ]
	if (harvest.state) {
		command += ["-st", harvest.state]
	} 
	if (harvest.user && harvest.password) {
		command += ["-usr", harvest.user]
		command += ["-pw", harvest.password]
	} else {
		command += ["-prompt"]
	}
	return command
}

/** Checks out the given version of the given file from Harvest. */
def checkoutVersion = { file, version ->
	def options = [ workingDir: gitbridge.gitroot ]
	def command = getHarvestCommand("hco")
	command += [ "-s", "$file", "-vn", version, "-br", "-r" ]
	shell(options, command)
}

/**
 * Fetches version information using the hsv command. Returns the result as a string.
 */
def fetchVersions = { lastFetch, currentFetch ->
	def options = [ workingDir: gitbridge.datadir ]
	def command = getHarvestCommand("hsv")
	def from = LocalDateTime.ofEpochSecond(lastFetch.intdiv(1000), 1000 * (lastFetch % 1000) as Integer, ZoneOffset.UTC).format(formats.US_DATE)
	def to = LocalDateTime.ofEpochSecond(currentFetch.intdiv(1000), 1000 * (currentFetch % 1000) as Integer, ZoneOffset.UTC).plusDays(1).format(formats.US_DATE)
	command += [ "-s", "*", "-iv", "av", "-id", "sd", from, to ]
	shell(options, command)

	def hsvOutputFile = file("${gitbridge.datadir}/hsv.log")
	assert hsvOutputFile.exists()
	def hsvOutputLines = hsvOutputFile.readLines()
	assert hsvOutputLines.size() >= 4

	hsvOutputFile.delete()
	hsvOutputLines.remove(2)
	hsvOutputLines.remove(0)
	return hsvOutputLines.dropRight(2).join("\n")
}

/** Converts the given time string from Harvest's hsv output format to git commit format. */
def convertTimestamp = {
	return LocalDateTime.parse(it, formats.HARVEST).format(formats.GIT_COMMIT)
}

/** 
 * Stages all changes in gitbridge.gitroot and commits them with the given
 * author, message, and commit time.
 */
def commit = { author, message, time ->
	def options = [ environment: ["GIT_COMMITTER_DATE": time ], workingDir: gitbridge.gitroot ]
	println shell(options, ["git", "add", "."])
	println shell(options, ["git", "commit", "--allow-empty", "--date=$time", "--author=\"$author\"", "-m", "$message"])
}

/**
 * Initializes the git repository. Sets default committer and adds a .gitignore file
 * that prevents harvest signature files from being added to the repository.
 */
def initRepository = {
	println "${gitbridge.gitroot} does not seem to be a Git repository. Initializing."

	def options = [ environment: ["GIT_COMMITTER_DATE": "01/01/1970'T'00:00:00" ], workingDir: gitbridge.gitroot ]
	shell(options, ["git", "init"])
	shell(options, ["git", "config", "user.name", "CQSE Harvest Git Bridge"])
	shell(options, ["git", "config", "user.email", "nobody@nomail.com"])
	file("${gitbridge.gitroot}/.gitignore").write "harvest.sig\n"
	shell(options, ["git", "add", ".gitignore"])
	shell(options, ["git", "commit", "--date=01/01/1970'T'00:00:00", "-m", "Ignore Harvest Signatures"])
}

/**
 * Processes all file entries for a group of changes that belong to the same minute.
 * Entries with the "D" tag are removed from the repository, for all other entries we
 * checkout the provided version. The return value is a set of all individual change
 * times that were processed.
 */
def processFileEntries = { entries ->
	def committedTimes = [] as Set
	for(fileEntry in entries.sort{ LocalDateTime.parse(it.Modified, formats.HARVEST) }) {
		if(fileEntry.Tag == "D") {
			new FileNameFinder().getFileNames(gitbridge.gitroot, "**/${fileEntry.Name}").each { 
				println "Deleting $it"
				file(it).delete() 
			}
		} else {
			checkoutVersion(fileEntry.Name, fileEntry.Version)
		}
		committedTimes.add(fileEntry.Modified)
	}
	return committedTimes
}

/**
 * Main task. Checks Harvest for new changes, groups them into git commits and 
 * applies them to the git repository.
 */
task updateGit {
	doLast {
		assert harvest.broker != null
		assert file(gitbridge.datadir).exists()
		assert file(gitbridge.gitroot).exists()

		def gitFolder = file("${gitbridge.gitroot}/.git")
		if(!gitFolder.exists()) {
			initRepository();
		}

		def authorMappingFile = file("${gitbridge.datadir}/authors.properties")
		def authorMapping = new Properties()
		if(authorMappingFile.exists() && authorMappingFile.canRead()) {
			authorMapping.load(authorMappingFile.newReader())
		} else {
			println "No author mapping file found. Using defaults."
		}
		
		def commitsFile = file("${gitbridge.datadir}/processedCommits.txt")
		def processedCommits = (commitsFile.exists() ? commitsFile.readLines() : []) as Set
		
		def timestampFile = file("${gitbridge.datadir}/timestamp.txt")
		def lastFetch = Long.valueOf(timestampFile.exists() ? timestampFile.readLines()[0] : 0)
		def currentFetch = System.currentTimeMillis();

		def hsvOutput = fetchVersions(lastFetch, currentFetch)

		// Contains (among others): Name, Path, Version, Package, Modifier, Modified
		def changes = CsvParser.parseCsv( hsvOutput, separator: '\t' )

		// Ignore ones that we already have
		changes = changes.findAll( { !processedCommits.contains(it.Modified) } )
		
		// group by time (truncated to full minutes), package, and author
		def groupedChanges = changes.groupBy{ [ time: it.Modified.take(17) + "00", package: it.Package, author: it.Modifier] }

		// sort by parsed time
		groupedChanges = groupedChanges.sort{ LocalDateTime.parse(it.key.time, formats.HARVEST) }

		println "Found ${groupedChanges.size()} unprocessed changes."

		for(change in groupedChanges) {
			def gitAuthor = authorMapping[change.key.author]
			if(gitAuthor == null) {
				println "No author substitution found for ${change.key.author}. Using default."
				gitAuthor = "${change.key.author} <nobody@nomail.com>"
			}

			def committedTimes = processFileEntries(change.value)
			commit(gitAuthor, change.key.package, convertTimestamp(change.key.time))
			commitsFile.withWriterAppend { out -> committedTimes.toSorted().each { out.println it } }
		}
		timestampFile.write "${currentFetch}"

		println "Done."
	}
}

